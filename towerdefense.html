<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tower Defense Command</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Press Start 2P', cursive;
            background-color: #1a202c;
            color: #a0aec0;
            user-select: none;
        }
        canvas {
            background-image:
                linear-gradient(rgba(0, 255, 0, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 0, 0.1) 1px, transparent 1px);
            background-size: 20px 20px;
            cursor: crosshair;
            border-radius: 0.5rem;
            border: 2px solid #4a5568;
        }
        .ui-panel {
            background-color: #2d3748;
            border: 2px solid #4a5568;
            border-radius: 0.5rem;
            padding: 1rem;
        }
        .tower-card, .game-button {
            border: 2px solid #4a5568;
            transition: all 0.2s ease-in-out;
        }
        .tower-card.selected, .tower-card:hover {
            background-color: #4a5568;
            border-color: #a0aec0;
            transform: translateY(-4px);
        }
        .game-button:hover {
            background-color: #4299e1;
            border-color: #90cdf4;
            color: #1a202c;
        }
        .game-button:active {
            transform: translateY(2px);
        }
        .stat-box {
            background-color: #1a202c;
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            border: 2px solid #4a5568;
        }
        .modal {
            display: none; /* Hidden by default */
            position: fixed;
            z-index: 100;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.7);
        }
        .modal-content {
            background-color: #2d3748;
            margin: 15% auto;
            padding: 2rem;
            border: 2px solid #a0aec0;
            width: 80%;
            max-width: 500px;
            text-align: center;
            border-radius: 0.5rem;
            animation: slide-down 0.5s ease-out;
        }
        @keyframes slide-down {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-4">

    <h1 class="text-4xl text-green-400 mb-4 tracking-wider">Tower Defense Command</h1>

    <div class="w-full max-w-7xl flex flex-col lg:flex-row gap-4">
        <!-- Game Canvas -->
        <div class="flex-grow">
            <canvas id="gameCanvas"></canvas>
        </div>

        <!-- UI Panel -->
        <div class="lg:w-72 w-full flex-shrink-0 ui-panel flex flex-col gap-4">
            <div class="grid grid-cols-3 gap-2 text-center">
                <div class="stat-box">
                    <div class="text-yellow-400 text-2xl" id="gold">200</div>
                    <div class="text-xs">GOLD</div>
                </div>
                <div class="stat-box">
                    <div class="text-red-400 text-2xl" id="lives">20</div>
                    <div class="text-xs">LIVES</div>
                </div>
                <div class="stat-box">
                    <div class="text-blue-400 text-2xl" id="wave">0</div>
                    <div class="text-xs">WAVE</div>
                </div>
            </div>

            <div id="tower-selection" class="flex flex-col gap-2">
                <h2 class="text-lg text-center">TOWERS</h2>
                <!-- Tower Cards will be injected here -->
            </div>

            <button id="startWaveBtn" class="w-full p-3 bg-blue-600 rounded-lg game-button">START WAVE</button>
            <div id="waveInfo" class="text-center text-sm h-8 text-yellow-400"></div>
        </div>
    </div>

    <!-- Game Over Modal -->
    <div id="gameOverModal" class="modal">
        <div class="modal-content">
            <h2 id="modalTitle" class="text-3xl mb-4 text-red-500">GAME OVER</h2>
            <p id="modalText" class="mb-6">The enemy has breached your defenses!</p>
            <button onclick="location.reload()" class="p-3 bg-blue-600 rounded-lg game-button w-1/2">RESTART</button>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');

            const goldEl = document.getElementById('gold');
            const livesEl = document.getElementById('lives');
            const waveEl = document.getElementById('wave');
            const startWaveBtn = document.getElementById('startWaveBtn');
            const waveInfoEl = document.getElementById('waveInfo');
            const towerSelectionEl = document.getElementById('tower-selection');
            const gameOverModal = document.getElementById('gameOverModal');
            const modalTitleEl = document.getElementById('modalTitle');
            const modalTextEl = document.getElementById('modalText');

            let parentDiv = canvas.parentElement;
            let TILE_SIZE = 40;

            function resizeCanvas() {
                const availableWidth = parentDiv.clientWidth;
                const cols = Math.floor(availableWidth / TILE_SIZE);
                canvas.width = cols * TILE_SIZE;
                canvas.height = Math.floor(cols * TILE_SIZE * 0.7); // Maintain aspect ratio
                drawMap();
            }

            // --- Game State ---
            let gold = 200;
            let lives = 20;
            let wave = 0;
            let enemies = [];
            let towers = [];
            let projectiles = [];
            let selectedTower = null;
            let mouse = { x: 0, y: 0 };
            let waveInProgress = false;
            let gameOver = false;
            let lastWaveEndTime = 0;

            // --- Game Configuration ---
            const path = [
                { x: 0, y: 3 }, { x: 4, y: 3 }, { x: 4, y: 7 }, { x: 9, y: 7 },
                { x: 9, y: 2 }, { x: 15, y: 2 }, { x: 15, y: 9 }, { x: 19, y: 9 }
            ];

            const TOWER_TYPES = {
                'archer': { name: 'Archer', cost: 100, damage: 30, range: 3 * TILE_SIZE, fireRate: 30, color: '#38b2ac', projectileSpeed: 8, projectileColor: '#81e6d9' },
                'cannon': { name: 'Cannon', cost: 250, damage: 100, range: 4 * TILE_SIZE, fireRate: 100, color: '#f56565', projectileSpeed: 5, projectileColor: '#feb2b2', splashRadius: 1 * TILE_SIZE },
                'wizard': { name: 'Wizard', cost: 400, damage: 60, range: 3.5 * TILE_SIZE, fireRate: 70, color: '#9f7aea', projectileSpeed: 6, projectileColor: '#d6bcfa', slow: 0.5, slowDuration: 60 }
            };
            
            const ENEMY_TYPES = {
                'standard': { health: 100, speed: 1.5, gold: 5, color: '#4299e1' },
                'fast': { health: 70, speed: 2.5, gold: 7, color: '#f6e05e' },
                'tank': { health: 500, speed: 1, gold: 20, color: '#718096' }
            };
            
            const WAVES = [
                { 'standard': 10 },
                { 'standard': 15, 'fast': 5 },
                { 'standard': 20, 'tank': 2 },
                { 'fast': 20, 'tank': 3 },
                { 'standard': 20, 'fast': 15, 'tank': 5 },
                { 'tank': 10, 'fast': 10 },
                { 'wizard': 1, 'tank': 15 }, // boss wave placeholder
                { 'standard': 50, 'fast': 30, 'tank': 10 }
            ];

            // --- Audio ---
            // Use PolySynth for sounds that can overlap rapidly to prevent errors
            const shootSynth = new Tone.PolySynth(Tone.Synth, { maxPolyphony: 8, volume: -12, envelope: { attack: 0.005, decay: 0.1, sustain: 0.1, release: 0.2 }, }).toDestination();
            const cannonSynth = new Tone.PolySynth(Tone.MetalSynth, { maxPolyphony: 4, volume: -8, envelope: { attack: 0.001, decay: 0.1, release: 0.01 }, harmonicity: 3.1, modulationIndex: 16, resonance: 4000, octaves: 1.5 }).toDestination();
            const wizardSynth = new Tone.PolySynth(Tone.MembraneSynth, { maxPolyphony: 4, volume: -10 }).toDestination();
            const hitSynth = new Tone.PolySynth(Tone.Synth, { maxPolyphony: 8, volume: -20, envelope: { attack: 0.001, decay: 0.05, release: 0.05 }}).toDestination();
            const lifeSynth = new Tone.PolySynth(Tone.Synth, { maxPolyphony: 4, volume: -10 }).toDestination();
            
            // Single synths for non-overlapping sounds
            const simpleSynth = new Tone.Synth().toDestination();

            function playSound(type) {
                if (Tone.context.state !== 'running') {
                    Tone.start();
                }
                const now = Tone.now();
                switch (type) {
                    case 'place':
                        simpleSynth.triggerAttackRelease("C4", "8n", now);
                        break;
                    case 'shoot_archer':
                        shootSynth.triggerAttackRelease("C5", "16n", now);
                        break;
                    case 'shoot_cannon':
                        cannonSynth.triggerAttackRelease("C2", "8n", now, 0.5);
                        break;
                    case 'shoot_wizard':
                        wizardSynth.triggerAttackRelease("G4", "16n", now, 0.8);
                        break;
                    case 'hit':
                        hitSynth.triggerAttackRelease("E3", "16n", now);
                        break;
                    case 'lose_life':
                        lifeSynth.triggerAttackRelease("C3", "4n", now);
                        break;
                    case 'game_over':
                        simpleSynth.triggerAttackRelease("C2", "2n", now);
                        simpleSynth.triggerAttackRelease("G1", "2n", now + 0.2);
                        break;
                    case 'win':
                        simpleSynth.triggerAttackRelease("C4", "4n", now);
                        simpleSynth.triggerAttackRelease("E4", "4n", now + 0.2);
                        simpleSynth.triggerAttackRelease("G4", "4n", now + 0.4);
                        break;
                }
            }


            // --- Classes ---
            class Enemy {
                constructor(type) {
                    this.type = type;
                    this.x = path[0].x * TILE_SIZE + TILE_SIZE / 2;
                    this.y = path[0].y * TILE_SIZE + TILE_SIZE / 2;
                    this.pathIndex = 0;
                    this.maxHealth = ENEMY_TYPES[type].health * (1 + wave * 0.1);
                    this.health = this.maxHealth;
                    this.speed = ENEMY_TYPES[type].speed;
                    this.gold = ENEMY_TYPES[type].gold;
                    this.color = ENEMY_TYPES[type].color;
                    this.radius = TILE_SIZE * 0.4;
                    this.effects = { slow: { active: false, duration: 0, multiplier: 1 } };
                }

                draw() {
                    // Body
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fill();

                    // Health bar
                    const healthBarWidth = this.radius * 1.5;
                    const healthBarHeight = 5;
                    ctx.fillStyle = '#4a5568';
                    ctx.fillRect(this.x - healthBarWidth / 2, this.y - this.radius - healthBarHeight - 2, healthBarWidth, healthBarHeight);
                    ctx.fillStyle = '#48bb78';
                    ctx.fillRect(this.x - healthBarWidth / 2, this.y - this.radius - healthBarHeight - 2, healthBarWidth * (this.health / this.maxHealth), healthBarHeight);
                
                    // Slow effect visual
                    if(this.effects.slow.active) {
                        ctx.fillStyle = 'rgba(173, 216, 230, 0.5)';
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.radius + 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                update() {
                    this.updateEffects();
                    const targetNode = path[this.pathIndex + 1];
                    if (!targetNode) {
                        this.reachEnd();
                        return;
                    }
                    
                    const targetX = targetNode.x * TILE_SIZE + TILE_SIZE / 2;
                    const targetY = targetNode.y * TILE_SIZE + TILE_SIZE / 2;
                    const dx = targetX - this.x;
                    const dy = targetY - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const currentSpeed = this.speed * this.effects.slow.multiplier;

                    if (dist < currentSpeed) {
                        this.pathIndex++;
                    } else {
                        this.x += (dx / dist) * currentSpeed;
                        this.y += (dy / dist) * currentSpeed;
                    }
                }
                
                updateEffects() {
                    if (this.effects.slow.active) {
                        this.effects.slow.duration--;
                        if (this.effects.slow.duration <= 0) {
                            this.effects.slow.active = false;
                            this.effects.slow.multiplier = 1;
                        }
                    }
                }
                
                applyEffect(effect) {
                    if (effect.type === 'slow') {
                        this.effects.slow.active = true;
                        this.effects.slow.duration = effect.duration;
                        this.effects.slow.multiplier = 1 - effect.power;
                    }
                }

                takeDamage(amount) {
                    this.health -= amount;
                    if (this.health <= 0) {
                        this.die();
                    }
                }

                die() {
                    gold += this.gold;
                    enemies = enemies.filter(e => e !== this);
                }

                reachEnd() {
                    lives--;
                    playSound('lose_life');
                    enemies = enemies.filter(e => e !== this);
                    if (lives <= 0) {
                        triggerGameOver(false);
                    }
                }
            }
            
            class Tower {
                constructor(x, y, type) {
                    this.x = (Math.floor(x / TILE_SIZE) + 0.5) * TILE_SIZE;
                    this.y = (Math.floor(y / TILE_SIZE) + 0.5) * TILE_SIZE;
                    this.type = type;
                    const stats = TOWER_TYPES[type];
                    Object.assign(this, stats);
                    this.target = null;
                    this.fireCooldown = 0;
                }

                draw() {
                    const radius = TILE_SIZE * 0.4;

                    // --- Draw Base based on type ---
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.strokeStyle = '#2d3748';
                    ctx.lineWidth = 4;
                    ctx.fillStyle = this.color;
                    
                    switch (this.type) {
                        case 'archer': // Circle base
                            ctx.beginPath();
                            ctx.arc(0, 0, radius, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.stroke();
                            break;
                        case 'cannon': // Square base
                            ctx.beginPath();
                            ctx.rect(-radius, -radius, radius * 2, radius * 2);
                            ctx.fill();
                            ctx.stroke();
                            break;
                        case 'wizard': // Pentagon base
                            ctx.beginPath();
                            for (let i = 0; i < 5; i++) {
                                ctx.lineTo(radius * Math.cos(2 * Math.PI * i / 5 - Math.PI / 2), radius * Math.sin(2 * Math.PI * i / 5 - Math.PI / 2));
                            }
                            ctx.closePath();
                            ctx.fill();
                            ctx.stroke();
                            break;
                    }
                    ctx.restore();


                    // --- Draw Gun/Top part ---
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    if (this.target) {
                        ctx.rotate(Math.atan2(this.target.y - this.y, this.target.x - this.x));
                    }
                    ctx.fillStyle = '#2d3748';
                    ctx.strokeStyle = this.color;
                    ctx.lineWidth = 2;

                    switch (this.type) {
                        case 'archer':
                            // Bow shape
                            ctx.beginPath();
                            ctx.moveTo(0, 0);
                            ctx.quadraticCurveTo(TILE_SIZE * 0.3, -TILE_SIZE * 0.3, TILE_SIZE * 0.5, 0);
                            ctx.quadraticCurveTo(TILE_SIZE * 0.3, TILE_SIZE * 0.3, 0, 0);
                            ctx.fillStyle = '#8B4513'; // Brown color for wood
                            ctx.fill();
                            // Arrow
                            ctx.fillStyle = '#2d3748';
                            ctx.fillRect(0, -1.5, TILE_SIZE * 0.6, 3);
                            break;
                        case 'cannon':
                            // Thicker, shorter barrel
                            ctx.fillStyle = '#4a5568';
                            ctx.fillRect(0, -TILE_SIZE * 0.15, TILE_SIZE * 0.4, TILE_SIZE * 0.3);
                            ctx.strokeRect(0, -TILE_SIZE * 0.15, TILE_SIZE * 0.4, TILE_SIZE * 0.3);
                            break;
                        case 'wizard':
                            // Staff
                            ctx.fillStyle = '#8B4513';
                            ctx.fillRect(0, -3, TILE_SIZE * 0.4, 6);
                            // Orb
                            ctx.fillStyle = this.projectileColor;
                            ctx.beginPath();
                            ctx.arc(TILE_SIZE * 0.45, 0, TILE_SIZE * 0.15, 0, Math.PI * 2);
                            ctx.fill();
                            // Aura effect for the orb
                            ctx.globalAlpha = 0.5 + Math.sin(Date.now() / 200) * 0.2;
                            ctx.beginPath();
                            ctx.arc(TILE_SIZE * 0.45, 0, TILE_SIZE * 0.2, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.globalAlpha = 1.0;
                            break;
                    }
                    ctx.restore();
                }


                drawRange() {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.range, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                }

                update() {
                    if (this.fireCooldown > 0) {
                        this.fireCooldown--;
                    }

                    if (!this.target || this.target.health <= 0 || this.distTo(this.target) > this.range) {
                        this.findTarget();
                    }

                    if (this.target && this.fireCooldown <= 0) {
                        this.shoot();
                        this.fireCooldown = this.fireRate;
                    }
                }

                findTarget() {
                    let closestDist = Infinity;
                    this.target = null;
                    for (const enemy of enemies) {
                        const dist = this.distTo(enemy);
                        if (dist < closestDist && dist <= this.range) {
                            closestDist = dist;
                            this.target = enemy;
                        }
                    }
                }

                distTo(enemy) {
                    const dx = this.x - enemy.x;
                    const dy = this.y - enemy.y;
                    return Math.sqrt(dx * dx + dy * dy);
                }

                shoot() {
                    projectiles.push(new Projectile(this.x, this.y, this.target, this));
                    playSound(`shoot_${this.type}`);
                }
            }

            class Projectile {
                constructor(x, y, target, tower) {
                    this.x = x;
                    this.y = y;
                    this.target = target;
                    this.towerType = tower.type;
                    const stats = TOWER_TYPES[this.towerType];
                    this.speed = stats.projectileSpeed;
                    this.damage = stats.damage;
                    this.color = stats.projectileColor;
                    this.splashRadius = stats.splashRadius || 0;
                    if(stats.slow) {
                        this.slowEffect = { type: 'slow', power: stats.slow, duration: stats.slowDuration };
                    }
                    this.radius = 5;
                }

                update() {
                    if (!this.target || this.target.health <= 0) {
                        this.destroy();
                        return;
                    }
                    const dx = this.target.x - this.x;
                    const dy = this.target.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < this.speed) {
                        this.hitTarget();
                    } else {
                        this.x += (dx / dist) * this.speed;
                        this.y += (dy / dist) * this.speed;
                    }
                }

                draw() {
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                hitTarget() {
                    playSound('hit');
                    if (this.splashRadius > 0) {
                        enemies.forEach(enemy => {
                            const dx = this.target.x - enemy.x;
                            const dy = this.target.y - enemy.y;
                            if (Math.sqrt(dx*dx + dy*dy) <= this.splashRadius) {
                                enemy.takeDamage(this.damage);
                            }
                        });
                    } else {
                         this.target.takeDamage(this.damage);
                    }
                    
                    if (this.slowEffect) {
                        this.target.applyEffect(this.slowEffect);
                    }

                    this.destroy();
                }

                destroy() {
                    projectiles = projectiles.filter(p => p !== this);
                }
            }

            // --- Game Logic ---
            function gameLoop() {
                if (gameOver) return;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawMap();

                enemies.forEach(e => { e.update(); e.draw(); });
                towers.forEach(t => { t.update(); t.draw(); });
                projectiles.forEach(p => { p.update(); p.draw(); });

                if (selectedTower) {
                    drawPlacementPreview();
                }
                
                updateUI();

                if (waveInProgress && enemies.length === 0) {
                    endWave();
                }

                requestAnimationFrame(gameLoop);
            }
            
            function updateUI() {
                goldEl.textContent = gold;
                livesEl.textContent = lives;
                waveEl.textContent = wave;
            }

            function drawMap() {
                const numCols = canvas.width / TILE_SIZE;
                const numRows = canvas.height / TILE_SIZE;
                 ctx.fillStyle = '#2d3748';
                 ctx.fillRect(0,0,canvas.width, canvas.height);

                ctx.strokeStyle = '#4a5568';
                ctx.lineWidth = TILE_SIZE;
                ctx.beginPath();
                ctx.moveTo(path[0].x * TILE_SIZE, path[0].y * TILE_SIZE + TILE_SIZE / 2);
                for (let i = 1; i < path.length; i++) {
                    ctx.lineTo(path[i].x * TILE_SIZE + TILE_SIZE/2, path[i].y * TILE_SIZE + TILE_SIZE / 2);
                }
                ctx.stroke();
            }
            
            function isValidPlacement(x, y) {
                 if (x < 0 || y < 0 || x >= canvas.width || y >= canvas.height) return false;

                const gridX = Math.floor(x / TILE_SIZE);
                const gridY = Math.floor(y / TILE_SIZE);
                
                for(let tower of towers) {
                    const towerGridX = Math.floor(tower.x / TILE_SIZE);
                    const towerGridY = Math.floor(tower.y / TILE_SIZE);
                    if(gridX === towerGridX && gridY === towerGridY) return false;
                }

                // Check path proximity
                for (let i = 0; i < path.length - 1; i++) {
                    const start = path[i];
                    const end = path[i+1];
                    if (start.x === end.x && gridX === start.x && gridY >= Math.min(start.y, end.y) && gridY <= Math.max(start.y, end.y)) return false;
                    if (start.y === end.y && gridY === start.y && gridX >= Math.min(start.x, end.x) && gridX <= Math.max(start.x, end.x)) return false;
                }

                return true;
            }
            
            function drawPlacementPreview() {
                const gridX = Math.floor(mouse.x / TILE_SIZE);
                const gridY = Math.floor(mouse.y / TILE_SIZE);
                const x = (gridX + 0.5) * TILE_SIZE;
                const y = (gridY + 0.5) * TILE_SIZE;
                
                const towerType = TOWER_TYPES[selectedTower];
                const valid = isValidPlacement(mouse.x, mouse.y);

                // Range preview
                ctx.fillStyle = valid ? 'rgba(0, 255, 0, 0.2)' : 'rgba(255, 0, 0, 0.2)';
                ctx.strokeStyle = valid ? 'rgba(0, 255, 0, 0.5)' : 'rgba(255, 0, 0, 0.5)';
                ctx.beginPath();
                ctx.arc(x, y, towerType.range, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                // Tower preview
                ctx.fillStyle = towerType.color;
                ctx.globalAlpha = 0.7;
                ctx.beginPath();
                ctx.arc(x, y, TILE_SIZE * 0.4, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }

            function startWave() {
                // This guard prevents starting a wave if one is in progress, if the game is over,
                // or if the current wave number is already the total number of waves (meaning the last wave has been started).
                if (waveInProgress || gameOver || wave === WAVES.length) return;

                if (lastWaveEndTime > 0) {
                    const timeElapsed = Date.now() - lastWaveEndTime;
                    const maxBonusTime = 8000; // 8 seconds to get a bonus
                    if (timeElapsed < maxBonusTime) {
                        const bonus = Math.floor(Math.max(0, 50 * (1 - timeElapsed / maxBonusTime)));
                        if (bonus > 0) {
                            gold += bonus;
                            waveInfoEl.textContent = `+${bonus}G EARLY BONUS!`;
                            setTimeout(() => { 
                                if (waveInfoEl.textContent.includes(`+${bonus}G`)) {
                                    waveInfoEl.textContent = '';
                                }
                             }, 2000);
                        }
                    }
                }
                lastWaveEndTime = 0; // Consume the bonus chance

                waveInProgress = true;
                wave++;
                startWaveBtn.disabled = true;
                startWaveBtn.textContent = `WAVE ${wave} IN PROGRESS`;
                startWaveBtn.classList.remove('bg-blue-600');
                startWaveBtn.classList.add('bg-gray-700');
                
                const currentWave = WAVES[wave - 1];
                
                let spawnQueue = [];
                for(const type in currentWave) {
                    for(let i=0; i<currentWave[type]; i++) {
                        spawnQueue.push(type);
                    }
                }
                spawnQueue.sort(() => Math.random() - 0.5);

                let spawnedCount = 0;
                const spawnInterval = setInterval(() => {
                    if (spawnedCount < spawnQueue.length) {
                        enemies.push(new Enemy(spawnQueue[spawnedCount]));
                        spawnedCount++;
                    } else {
                        clearInterval(spawnInterval);
                    }
                }, 500);
            }

            function endWave() {
                waveInProgress = false;

                // Check for win condition only after the final wave is defeated.
                if (wave === WAVES.length) {
                    triggerGameOver(true);
                    startWaveBtn.disabled = true;
                    startWaveBtn.textContent = "VICTORY!";
                    startWaveBtn.classList.remove('bg-blue-600');
                    startWaveBtn.classList.add('bg-gray-700');
                    return;
                }

                lastWaveEndTime = Date.now();
                startWaveBtn.disabled = false;
                startWaveBtn.textContent = `START WAVE ${wave + 1}`;
                startWaveBtn.classList.add('bg-blue-600');
                startWaveBtn.classList.remove('bg-gray-700');
                gold += 100 + wave * 10; // Wave completion bonus
            }

            function triggerGameOver(isWin) {
                if (gameOver) return;
                gameOver = true;
                waveInProgress = false;
                if (isWin) {
                    modalTitleEl.textContent = "VICTORY!";
                    modalTitleEl.classList.remove('text-red-500');
                    modalTitleEl.classList.add('text-green-400');
                    modalTextEl.textContent = `You have defended the realm against all ${WAVES.length} waves!`;
                    playSound('win');
                } else {
                    modalTitleEl.textContent = "GAME OVER";
                    modalTitleEl.classList.add('text-red-500');
                    modalTitleEl.classList.remove('text-green-400');
                    modalTextEl.textContent = `The enemy breached your defenses on wave ${wave}.`;
                    playSound('game_over');
                }
                gameOverModal.style.display = 'flex';
            }

            // --- Event Listeners ---
            startWaveBtn.addEventListener('click', startWave);

            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                mouse.x = e.clientX - rect.left;
                mouse.y = e.clientY - rect.top;
            });

            canvas.addEventListener('click', () => {
                if (selectedTower) {
                    const towerCost = TOWER_TYPES[selectedTower].cost;
                    if (gold >= towerCost && isValidPlacement(mouse.x, mouse.y)) {
                        gold -= towerCost;
                        towers.push(new Tower(mouse.x, mouse.y, selectedTower));
                        playSound('place');
                    }
                }
            });
            
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && selectedTower) {
                    selectedTower = null;
                    document.querySelectorAll('.tower-card').forEach(c => c.classList.remove('selected'));
                }
            });
            
            function createTowerUI() {
                let content = '<h2 class="text-lg text-center">TOWERS</h2>';
                for(const key in TOWER_TYPES) {
                    const t = TOWER_TYPES[key];
                    content += `
                        <div class="p-2 rounded-lg tower-card cursor-pointer" data-tower="${key}">
                            <div class="flex justify-between items-center">
                                <span class="text-md">${t.name}</span>
                                <span class="text-yellow-400">${t.cost}G</span>
                            </div>
                            <div class="text-xs mt-1 text-gray-400">
                                DMG: ${t.damage} | RNG: ${t.range/TILE_SIZE} | SPD: ${(1000/(t.fireRate * (1000/60))).toFixed(1)}/s
                            </div>
                        </div>
                    `;
                }
                towerSelectionEl.innerHTML = content;
                
                document.querySelectorAll('.tower-card').forEach(card => {
                    card.addEventListener('click', () => {
                        document.querySelectorAll('.tower-card').forEach(c => c.classList.remove('selected'));
                        card.classList.add('selected');
                        selectedTower = card.dataset.tower;
                    });
                });
            }

            // --- Initialization ---
            function init() {
                resizeCanvas();
                window.addEventListener('resize', resizeCanvas);
                createTowerUI();
                gameLoop();
            }

            init();
        });
    </script>
</body>
</html>
